0 부터 N 까지의 각 자릿수의 합을 효율적으로 구하기 위해서는 각 자리에 0~9 까지의 수가 몇번 등장하는지 카운트 하는 것이 핵심입니다.

```java
private long sum(long n) {
	if (n <= 0) {
		return 0;
	}
	long s = 1, sum = 0, t, r;
	long[] c = new long[10];
	
	Arrays.fill(c, 0);
	while (n > 0) {
		t = n / (s * 10);
		r = n % (s * 10);
		for (int i = 0; i < 10; ++i) {
			c[i] += t * s;
		}
		for (int i = 1; i <= r / s; ++i) {
			c[i] += s;
		}
		c[(int)((r / s + 1) % 10)] += r % s;
		n -= 9 * s;
		s *= 10;
	}
	
	for (int i = 1; i < 10; ++i) {
		sum += i * c[i];
	}
	return sum;
}
```

### 변수 설명:

- `s`: 현재 처리중인 자리수의 가중치 (예: 1은 일의 자리, 10은 십의 자리).
- `sum`: 최종 합계를 저장하는 변수.
- `t`: 전체 범위에서 현재 자리수를 제외한 나머지 상위 자리수의 각 숫자가 등장하는 횟수.
- `r`: 현재 `s` 자리수에 해당하는 나머지 부분.
- `c`: 각 숫자(0부터 9까지)가 각 자리수에 나타나는 총 횟수를 저장하는 배열.

### 알고리즘의 핵심 로직:

1. **초기화**:
    
    - 각 자리수의 숫자 빈도를 저장할 배열 `c`를 0으로 초기화합니다.
    - `s`는 1부터 시작하여, 각 반복에서 10씩 곱해져 다음 자리수로 이동합니다.
2. **자리수별 숫자 빈도 계산**:
    
    - `t`는 `n`을 `s * 10`으로 나눈 몫입니다. 이 값은 현재 자리수를 제외한 상위 자리수에서 각 숫자가 몇 번 반복되는지 나타냅니다. 예를 들어, 3050이면, 일의 자리를 보는 경우, 300번 각 숫자(0~9)가 등장합니다.
    - 각 숫자는 `t * s`번 등장하므로 `c[i]`에 더해줍니다.
    - `r`은 `n`을 `s * 10`으로 나눈 나머지입니다. 이는 현재 자리수의 숫자와 그 이하 자리수의 숫자들을 나타냅니다.
    - `r / s`를 계산하여 현재 자리수에서 나타나는 숫자를 구하고, `1`부터 `r / s`까지의 숫자 각각이 `s`번 나타나므로 `c[i]`에 `s`를 더합니다.
    - 마지막으로 `r % s`는 현재 자리수의 숫자가 불완전하게 나타나는 경우를 처리합니다.
3. **최종 합계 계산**:
    
    - `n`을 갱신하여 `n -= 9 * s` 실행. 이는 다음 자리수로 넘어가기 위한 처리입니다.
    - 배열 `c`에 저장된 값에 대해 각 숫자의 가중치를 곱하여 `sum`에 더합니다. 즉, `sum += i * c[i]` (단, i는 1부터 9까지).

### 시간 복잡도:

- 이 알고리즘의 시간 복잡도는 각 자리수마다 숫자 빈도를 계산하기 때문에, 최대 자리수의 크기에 선형적입니다(`O(log10(n))`).